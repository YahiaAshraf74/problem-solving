/**
 * code generated by JHelper
 * More info: https://g...content-available-to-author-only...b.com/AlexeyDmitriev/JHelper
 * @author YahiaAshraf74
 */

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cmath>
#include <vector>
#include <set>
#include <map>
#include <unordered_set>
#include <unordered_map>
#include <queue>
#include<stack>
#include <complex>
#include <string>
#include <cstring>
#include <random>
#include <bitset>
#include <ios>
#include<iomanip>
#include <stdio.h>
#include <string.h>
#include<fstream>

using namespace std;
#define el          '\n'
#define pb(x)       push_back((x))
#define all(v)      ((v).begin()),((v).end())
#define clr(a, b)    memset(a,b,sizeof(a))
typedef long long ll;
const double EPS = 1e-8, PI = acos(-1);
const int N = 1e2 + 5, M = 4e4 + 5, OO = 0x3f3f3f3f, MOD = (int) 1e9 + 7;

int par[N];
vector<pair<pair<int, bool>, pair<int, int> > > edges;

void init(int n) {
    for (int i = 0; i < n; ++i) {
        par[i] = i;
    }
    edges.clear();
}

int find(int u) {
    if (par[u] == u)
        return u;
    return par[u] = find(par[u]);
}

bool join(int u, int v) {
    int parU = find(u), parV = find(v);
    if (parU == parV)
        return false;
    par[parU] = parV;
    return true;
}

class IsThereASecondWayLeft {
public:
    void solve(istream &cin, ostream &cout) {
        int T, testCases = 0;
        cin >> T;
        while (T--) {
            int n, m;
            cin >> n >> m;
            init(n);
            while (m--) {
                int from, to, cost;
                cin >> from >> to >> cost;
                --from, --to;
                edges.push_back(make_pair(make_pair(cost, false), make_pair(from, to)));
            }
            sort(all(edges));
            int compeleteSpanning = 0;
            for (int i = 0; i < edges.size(); ++i) {
                if (join(edges[i].second.first, edges[i].second.second)) {
                    edges[i].first.second = true;
                    ++compeleteSpanning;
                }
            }
            cout << "Case #" << ++testCases << " : ";
            if (compeleteSpanning != n - 1) {
                cout << "No way" << el;
                continue;
            }
            int candidateSecondMST = 0, secondMST = OO;
            for (int i = 0; i < edges.size(); ++i) {
                if (edges[i].first.second == true) {
                    candidateSecondMST = compeleteSpanning = 0;
                    for (int i = 0; i < n; ++i)
                        par[i] = i;
                    for (int j = 0; j < edges.size(); ++j) {
                        if (i != j && join(edges[j].second.first, edges[j].second.second)) {
                            candidateSecondMST += edges[j].first.first;
                            ++compeleteSpanning;
                        }
                    }
                    if (compeleteSpanning == n - 1) {
                        secondMST = min(secondMST, candidateSecondMST);
                    }
                }
            }
            if (secondMST == OO) {
                cout << "No second way" << el;
            } else {
                cout << secondMST << el;
            }
        }
    }
};

int main() {
	ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
	IsThereASecondWayLeft solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
